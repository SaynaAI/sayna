//! WebSocket message types and routing
//!
//! This module defines all message types for WebSocket communication,
//! including incoming and outgoing messages, unified message structures,
//! and message routing for optimized throughput.

use bytes::Bytes;
use serde::{Deserialize, Serialize};

use super::config::{
    LiveKitWebSocketConfig, STTWebSocketConfig, TTSWebSocketConfig, TurnDetectConfigUpdate,
    VADConfigUpdate, default_allow_interruption, default_audio_enabled,
};

/// WebSocket message types for incoming messages
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
#[allow(clippy::large_enum_variant)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum IncomingMessage {
    #[serde(rename = "config")]
    Config {
        /// Optional unique identifier for this WebSocket session.
        /// Used for recording paths and session tracking.
        /// If not provided, a UUID v4 will be auto-generated by the server.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: Option<String>,
        /// Enable audio processing (STT/TTS). Defaults to true if not specified.
        #[serde(
            default = "default_audio_enabled",
            skip_serializing_if = "Option::is_none"
        )]
        audio: Option<bool>,
        /// STT configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        stt_config: Option<STTWebSocketConfig>,
        /// TTS configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        tts_config: Option<TTSWebSocketConfig>,
        /// Optional LiveKit configuration for real-time audio streaming
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit: Option<LiveKitWebSocketConfig>,
    },
    #[serde(rename = "speak")]
    Speak {
        /// Text to synthesize
        text: String,
        /// Flush TTS buffer immediately
        #[serde(skip_serializing_if = "Option::is_none")]
        flush: Option<bool>,
        /// Allow this TTS to be interrupted
        #[serde(
            default = "default_allow_interruption",
            skip_serializing_if = "Option::is_none"
        )]
        allow_interruption: Option<bool>,
    },
    #[serde(rename = "clear")]
    Clear,
    #[serde(rename = "send_message")]
    SendMessage {
        /// Message content
        message: String,
        /// Message role (e.g., "user", "assistant")
        role: String,
        /// Optional topic/channel
        #[serde(skip_serializing_if = "Option::is_none")]
        topic: Option<String>,
        /// Optional debug metadata
        #[serde(skip_serializing_if = "Option::is_none")]
        debug: Option<serde_json::Value>,
    },
    /// Transfer the current SIP call to another phone number.
    ///
    /// This command initiates a SIP REFER transfer for the current participant
    /// in the LiveKit room. The participant identity and room name are derived
    /// from the WebSocket connection state.
    #[serde(rename = "sip_transfer")]
    SIPTransfer {
        /// The destination phone number to transfer the call to.
        ///
        /// Accepts phone numbers in various formats:
        /// - International format with `+` prefix (e.g., "+1234567890")
        /// - National format without prefix (e.g., "1234567890")
        /// - Internal extensions (e.g., "1234")
        ///
        /// Validation is performed by the handler, not during deserialization.
        #[cfg_attr(feature = "openapi", schema(example = "+1234567890"))]
        transfer_to: String,
    },
    /// Update runtime configuration for VAD and turn detection.
    ///
    /// This message allows dynamic adjustment of VAD and turn detection parameters
    /// during an active WebSocket session. Only parameters that are provided will
    /// be updated; omitted parameters retain their current values.
    ///
    /// **Note**: These settings affect the shared turn detector and may impact
    /// other active sessions using the same server instance.
    #[serde(rename = "update_config")]
    UpdateConfig {
        /// VAD configuration updates (silence threshold, etc.)
        #[serde(skip_serializing_if = "Option::is_none")]
        vad: Option<VADConfigUpdate>,
        /// Turn detection configuration updates (probability threshold)
        #[serde(skip_serializing_if = "Option::is_none")]
        turn_detect: Option<TurnDetectConfigUpdate>,
    },
}

/// Unified message structure for all incoming messages from various sources
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct UnifiedMessage {
    /// Text message content (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Binary data encoded as base64 (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Participant/sender identity
    pub identity: String,
    /// Topic/channel for the message
    pub topic: String,
    /// Room/space identifier
    pub room: String,
    /// Timestamp when the message was received
    pub timestamp: u64,
}

/// Participant disconnection information
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct ParticipantDisconnectedInfo {
    /// Participant's unique identity
    pub identity: String,
    /// Participant's display name (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Room identifier
    pub room: String,
    /// Timestamp when the disconnection occurred
    pub timestamp: u64,
}

/// WebSocket message types for outgoing messages
#[derive(Debug, Serialize)]
#[serde(tag = "type")]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum OutgoingMessage {
    #[serde(rename = "ready")]
    Ready {
        /// Unique identifier for this WebSocket session.
        /// Either provided by the client in config or auto-generated by server (UUID v4).
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: String,
        /// Optional LiveKit room name that was created
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_room_name: Option<String>,
        /// Optional LiveKit URL to connect to
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_url: Option<String>,
        /// Optional identity of the AI agent participant in the room
        #[serde(skip_serializing_if = "Option::is_none")]
        sayna_participant_identity: Option<String>,
        /// Optional display name of the AI agent participant
        #[serde(skip_serializing_if = "Option::is_none")]
        sayna_participant_name: Option<String>,
    },
    #[serde(rename = "stt_result")]
    STTResult {
        /// Transcribed text
        transcript: String,
        /// Whether this is the final version of the transcript
        is_final: bool,
        /// Whether the speaker has finished speaking (turn detection via VAD + Smart Turn)
        is_speech_final: bool,
        /// Confidence score (0.0 to 1.0)
        confidence: f32,
    },
    #[serde(rename = "message")]
    Message {
        /// Unified message structure containing text/data from various sources
        message: UnifiedMessage,
    },
    #[serde(rename = "participant_disconnected")]
    ParticipantDisconnected {
        /// Information about the participant who disconnected
        participant: ParticipantDisconnectedInfo,
    },
    /// TTS playback completion notification
    #[serde(rename = "tts_playback_complete")]
    TTSPlaybackComplete {
        /// Timestamp when completion occurred (milliseconds since epoch)
        timestamp: u64,
    },
    /// VAD event notification
    ///
    /// Emitted when VAD detects speech activity changes:
    /// - `speech_start`: User started speaking
    /// - `silence_detected`: Brief silence detected
    /// - `speech_resumed`: User resumed speaking after brief silence
    /// - `turn_end`: Silence exceeded threshold, turn complete
    #[serde(rename = "vad_event")]
    VadEvent {
        /// Event type: "speech_start", "silence_detected", "speech_resumed", "turn_end"
        #[cfg_attr(feature = "openapi", schema(example = "turn_end"))]
        event: String,
        /// Timestamp when the event occurred (milliseconds since epoch)
        #[cfg_attr(feature = "openapi", schema(example = 1704067200000_u64))]
        timestamp_ms: u64,
        /// Silence duration in milliseconds (only present for silence_detected and turn_end events)
        #[serde(skip_serializing_if = "Option::is_none")]
        silence_duration_ms: Option<u64>,
    },
    #[serde(rename = "error")]
    Error {
        /// Error message
        message: String,
    },
    /// SIP transfer specific error
    ///
    /// This message is sent when a SIP transfer operation fails.
    /// Clients can subscribe to this specific error type to handle
    /// SIP transfer failures separately from other errors.
    #[serde(rename = "sip_transfer_error")]
    SIPTransferError {
        /// Error message describing why the transfer failed
        message: String,
    },
}

/// Message routing for optimized throughput
/// Using enum for zero-cost abstraction
pub enum MessageRoute {
    Outgoing(OutgoingMessage),
    Binary(Bytes),
    Close,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;
    use uuid::Uuid;

    #[test]
    fn test_ready_message_serialization_full() {
        let ready = OutgoingMessage::Ready {
            stream_id: "test-stream-123".to_string(),
            livekit_room_name: Some("room-456".to_string()),
            livekit_url: Some("ws://localhost:7880".to_string()),
            sayna_participant_identity: Some("sayna-ai".to_string()),
            sayna_participant_name: Some("Sayna AI".to_string()),
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"test-stream-123""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(json.contains(r#""livekit_room_name":"room-456""#));
    }

    #[test]
    fn test_ready_message_serialization_minimal() {
        let ready = OutgoingMessage::Ready {
            stream_id: "minimal-stream".to_string(),
            livekit_room_name: None,
            livekit_url: None,
            sayna_participant_identity: None,
            sayna_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"minimal-stream""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(!json.contains("livekit_room_name"));
        assert!(!json.contains("livekit_url"));
        assert!(!json.contains("sayna_participant_identity"));
        assert!(!json.contains("sayna_participant_name"));
    }

    #[test]
    fn test_ready_message_with_uuid_stream_id() {
        let uuid = Uuid::new_v4().to_string();

        let ready = OutgoingMessage::Ready {
            stream_id: uuid.clone(),
            livekit_room_name: None,
            livekit_url: None,
            sayna_participant_identity: None,
            sayna_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(&uuid));
    }

    #[test]
    fn test_ready_message_stream_id_position() {
        let ready = OutgoingMessage::Ready {
            stream_id: "first-field".to_string(),
            livekit_room_name: Some("room".to_string()),
            livekit_url: None,
            sayna_participant_identity: None,
            sayna_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        let stream_id_pos = json.find("stream_id").expect("stream_id should exist");
        let room_pos = json
            .find("livekit_room_name")
            .expect("livekit_room_name should exist");

        assert!(
            stream_id_pos < room_pos,
            "stream_id should appear before livekit_room_name in JSON"
        );
    }

    #[test]
    fn test_sip_transfer_message_deserialization() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "+1234567890"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "+1234567890");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_without_plus_prefix() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "1234567890"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "1234567890");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_internal_extension() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "1234"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "1234");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_serialization() {
        let msg = IncomingMessage::SIPTransfer {
            transfer_to: "+1234567890".to_string(),
        };

        let json = serde_json::to_string(&msg).expect("Should serialize");
        assert!(json.contains(r#""type":"sip_transfer""#));
        assert!(json.contains(r#""transfer_to":"+1234567890""#));
    }

    #[test]
    fn test_sip_transfer_missing_field() {
        let json = r#"{"type": "sip_transfer"}"#;
        let result: Result<IncomingMessage, _> = serde_json::from_str(json);
        assert!(result.is_err(), "Should fail without transfer_to field");
    }

    #[test]
    fn test_sip_transfer_empty_transfer_to() {
        // Empty string is valid at deserialization time - validation happens later
        let json = r#"{"type": "sip_transfer", "transfer_to": ""}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_with_whitespace() {
        // Whitespace is preserved at deserialization - trimming happens in validation
        let json = r#"{"type": "sip_transfer", "transfer_to": "  +1234567890  "}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "  +1234567890  ");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_error_serialization() {
        let error = OutgoingMessage::SIPTransferError {
            message: "Invalid phone number".to_string(),
        };

        let json = serde_json::to_string(&error).expect("Should serialize");
        assert!(json.contains(r#""type":"sip_transfer_error""#));
        assert!(json.contains(r#""message":"Invalid phone number""#));
    }

    #[test]
    fn test_vad_event_serialization() {
        let event = OutgoingMessage::VadEvent {
            event: "turn_end".to_string(),
            timestamp_ms: 1704067200000,
            silence_duration_ms: Some(350),
        };

        let json = serde_json::to_string(&event).expect("Should serialize");
        assert!(json.contains(r#""type":"vad_event""#));
        assert!(json.contains(r#""event":"turn_end""#));
        assert!(json.contains(r#""timestamp_ms":1704067200000"#));
        assert!(json.contains(r#""silence_duration_ms":350"#));
    }

    #[test]
    fn test_vad_event_serialization_without_silence_duration() {
        let event = OutgoingMessage::VadEvent {
            event: "speech_start".to_string(),
            timestamp_ms: 1704067200000,
            silence_duration_ms: None,
        };

        let json = serde_json::to_string(&event).expect("Should serialize");
        assert!(json.contains(r#""type":"vad_event""#));
        assert!(json.contains(r#""event":"speech_start""#));
        assert!(json.contains(r#""timestamp_ms":1704067200000"#));
        // silence_duration_ms should be omitted
        assert!(!json.contains("silence_duration_ms"));
    }

    #[test]
    fn test_update_config_message_full() {
        let json = r#"{"type": "update_config", "vad": {"silence_duration_ms": 400}, "turn_detect": {"threshold": 0.6}}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::UpdateConfig { vad, turn_detect } => {
                assert!(vad.is_some());
                assert_eq!(vad.unwrap().silence_duration_ms, Some(400));
                assert!(turn_detect.is_some());
                assert_eq!(turn_detect.unwrap().threshold, Some(0.6));
            }
            _ => panic!("Expected UpdateConfig variant"),
        }
    }

    #[test]
    fn test_update_config_message_turn_detect_only() {
        let json = r#"{"type": "update_config", "turn_detect": {"threshold": 0.8}}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::UpdateConfig { vad, turn_detect } => {
                assert!(vad.is_none());
                assert!(turn_detect.is_some());
                assert_eq!(turn_detect.unwrap().threshold, Some(0.8));
            }
            _ => panic!("Expected UpdateConfig variant"),
        }
    }

    #[test]
    fn test_update_config_message_vad_only() {
        let json = r#"{"type": "update_config", "vad": {"silence_duration_ms": 250}}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::UpdateConfig { vad, turn_detect } => {
                assert!(vad.is_some());
                assert_eq!(vad.unwrap().silence_duration_ms, Some(250));
                assert!(turn_detect.is_none());
            }
            _ => panic!("Expected UpdateConfig variant"),
        }
    }

    #[test]
    fn test_update_config_message_empty() {
        let json = r#"{"type": "update_config"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::UpdateConfig { vad, turn_detect } => {
                assert!(vad.is_none());
                assert!(turn_detect.is_none());
            }
            _ => panic!("Expected UpdateConfig variant"),
        }
    }

    #[test]
    fn test_update_config_message_serialization() {
        let msg = IncomingMessage::UpdateConfig {
            vad: Some(VADConfigUpdate {
                silence_duration_ms: Some(300),
            }),
            turn_detect: Some(TurnDetectConfigUpdate {
                threshold: Some(0.5),
            }),
        };

        let json = serde_json::to_string(&msg).expect("Should serialize");
        assert!(json.contains(r#""type":"update_config""#));
        assert!(json.contains(r#""silence_duration_ms":300"#));
        assert!(json.contains(r#""threshold":0.5"#));
    }
}
