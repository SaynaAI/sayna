//! WebSocket message types and routing
//!
//! This module defines all message types for WebSocket communication,
//! including incoming and outgoing messages, unified message structures,
//! and message routing for optimized throughput.

use bytes::Bytes;
use serde::{Deserialize, Serialize};

use super::config::{
    LiveKitWebSocketConfig, STTWebSocketConfig, TTSWebSocketConfig, default_allow_interruption,
    default_audio_enabled,
};

/// WebSocket message types for incoming messages
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
#[allow(clippy::large_enum_variant)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum IncomingMessage {
    #[serde(rename = "config")]
    Config {
        /// Optional unique identifier for this WebSocket session.
        /// Used for recording paths and session tracking.
        /// If not provided, a UUID v4 will be auto-generated by the server.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: Option<String>,
        /// Enable audio processing (STT/TTS). Defaults to true if not specified.
        #[serde(
            default = "default_audio_enabled",
            skip_serializing_if = "Option::is_none"
        )]
        audio: Option<bool>,
        /// STT configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        stt_config: Option<STTWebSocketConfig>,
        /// TTS configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        tts_config: Option<TTSWebSocketConfig>,
        /// Optional LiveKit configuration for real-time audio streaming
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit: Option<LiveKitWebSocketConfig>,
    },
    #[serde(rename = "speak")]
    Speak {
        /// Text to synthesize
        text: String,
        /// Flush TTS buffer immediately
        #[serde(skip_serializing_if = "Option::is_none")]
        flush: Option<bool>,
        /// Allow this TTS to be interrupted
        #[serde(
            default = "default_allow_interruption",
            skip_serializing_if = "Option::is_none"
        )]
        allow_interruption: Option<bool>,
    },
    #[serde(rename = "clear")]
    Clear,
    #[serde(rename = "send_message")]
    SendMessage {
        /// Message content
        message: String,
        /// Message role (e.g., "user", "assistant")
        role: String,
        /// Optional topic/channel
        #[serde(skip_serializing_if = "Option::is_none")]
        topic: Option<String>,
        /// Optional debug metadata
        #[serde(skip_serializing_if = "Option::is_none")]
        debug: Option<serde_json::Value>,
    },
}

/// Unified message structure for all incoming messages from various sources
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct UnifiedMessage {
    /// Text message content (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Binary data encoded as base64 (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Participant/sender identity
    pub identity: String,
    /// Topic/channel for the message
    pub topic: String,
    /// Room/space identifier
    pub room: String,
    /// Timestamp when the message was received
    pub timestamp: u64,
}

/// Participant disconnection information
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct ParticipantDisconnectedInfo {
    /// Participant's unique identity
    pub identity: String,
    /// Participant's display name (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Room identifier
    pub room: String,
    /// Timestamp when the disconnection occurred
    pub timestamp: u64,
}

/// WebSocket message types for outgoing messages
#[derive(Debug, Serialize)]
#[serde(tag = "type")]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum OutgoingMessage {
    #[serde(rename = "ready")]
    Ready {
        /// Unique identifier for this WebSocket session.
        /// Either provided by the client in config or auto-generated by server (UUID v4).
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: String,
        /// Optional LiveKit room name that was created
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_room_name: Option<String>,
        /// Optional LiveKit URL to connect to
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_url: Option<String>,
        /// Optional identity of the AI agent participant in the room
        #[serde(skip_serializing_if = "Option::is_none")]
        sayna_participant_identity: Option<String>,
        /// Optional display name of the AI agent participant
        #[serde(skip_serializing_if = "Option::is_none")]
        sayna_participant_name: Option<String>,
    },
    #[serde(rename = "stt_result")]
    STTResult {
        /// Transcribed text
        transcript: String,
        /// Whether this is the final version of the transcript
        is_final: bool,
        /// Whether speech has ended
        is_speech_final: bool,
        /// Confidence score (0.0 to 1.0)
        confidence: f32,
    },
    #[serde(rename = "message")]
    Message {
        /// Unified message structure containing text/data from various sources
        message: UnifiedMessage,
    },
    #[serde(rename = "participant_disconnected")]
    ParticipantDisconnected {
        /// Information about the participant who disconnected
        participant: ParticipantDisconnectedInfo,
    },
    /// TTS playback completion notification
    #[serde(rename = "tts_playback_complete")]
    TTSPlaybackComplete {
        /// Timestamp when completion occurred (milliseconds since epoch)
        timestamp: u64,
    },
    #[serde(rename = "error")]
    Error {
        /// Error message
        message: String,
    },
}

/// Message routing for optimized throughput
/// Using enum for zero-cost abstraction
pub enum MessageRoute {
    Outgoing(OutgoingMessage),
    Binary(Bytes),
    Close,
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;
    use uuid::Uuid;

    #[test]
    fn test_ready_message_serialization_full() {
        let ready = OutgoingMessage::Ready {
            stream_id: "test-stream-123".to_string(),
            livekit_room_name: Some("room-456".to_string()),
            livekit_url: Some("ws://localhost:7880".to_string()),
            sayna_participant_identity: Some("sayna-ai".to_string()),
            sayna_participant_name: Some("Sayna AI".to_string()),
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"test-stream-123""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(json.contains(r#""livekit_room_name":"room-456""#));
    }

    #[test]
    fn test_ready_message_serialization_minimal() {
        let ready = OutgoingMessage::Ready {
            stream_id: "minimal-stream".to_string(),
            livekit_room_name: None,
            livekit_url: None,
            sayna_participant_identity: None,
            sayna_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"minimal-stream""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(!json.contains("livekit_room_name"));
        assert!(!json.contains("livekit_url"));
        assert!(!json.contains("sayna_participant_identity"));
        assert!(!json.contains("sayna_participant_name"));
    }

    #[test]
    fn test_ready_message_with_uuid_stream_id() {
        let uuid = Uuid::new_v4().to_string();

        let ready = OutgoingMessage::Ready {
            stream_id: uuid.clone(),
            livekit_room_name: None,
            livekit_url: None,
            sayna_participant_identity: None,
            sayna_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(&uuid));
    }

    #[test]
    fn test_ready_message_stream_id_position() {
        let ready = OutgoingMessage::Ready {
            stream_id: "first-field".to_string(),
            livekit_room_name: Some("room".to_string()),
            livekit_url: None,
            sayna_participant_identity: None,
            sayna_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        let stream_id_pos = json.find("stream_id").expect("stream_id should exist");
        let room_pos = json
            .find("livekit_room_name")
            .expect("livekit_room_name should exist");

        assert!(
            stream_id_pos < room_pos,
            "stream_id should appear before livekit_room_name in JSON"
        );
    }
}
